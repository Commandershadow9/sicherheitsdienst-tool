
services:
  # PostgreSQL Database
  db:
    image: postgres:15
    container_name: sicherheitsdienst-db
    restart: always
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-sicherheitsdienst_db}
      POSTGRES_USER: ${POSTGRES_USER:-admin}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD required}
    # SECURITY: Port nur lokal exponieren, damit der Host-API-Prozess zugreifen kann
    ports:
      - '127.0.0.1:5432:5432'
    volumes:
      - db-data:/var/lib/postgresql/data
    networks:
      - sicherheitsdienst-network
    healthcheck:
      test:
        [
          'CMD-SHELL',
          'pg_isready -U ${POSTGRES_USER:-admin} -d ${POSTGRES_DB:-sicherheitsdienst_db}',
        ]
      interval: 10s
      timeout: 5s
      retries: 5

  # Backend API (Node.js)
  api:
    build:
      context: ./backend
    container_name: sicherheitsdienst-api
    restart: unless-stopped
    environment:
      NODE_ENV: production
      PORT: 3001
      # Adjust to your DB credentials or override via environment
      DATABASE_URL: ${DATABASE_URL:-postgresql://${POSTGRES_USER:-admin}:${POSTGRES_PASSWORD:?POSTGRES_PASSWORD required}@db:5432/${POSTGRES_DB:-sicherheitsdienst_db}?schema=public}
      JWT_SECRET: ${JWT_SECRET:?JWT_SECRET required}
      # Optional Refresh/SMTP envs are passed if defined host-side
      REFRESH_SECRET: ${REFRESH_SECRET:?REFRESH_SECRET required}
      JWT_EXPIRES_IN: ${JWT_EXPIRES_IN:-}
      REFRESH_EXPIRES_IN: ${REFRESH_EXPIRES_IN:-}
      SMTP_HOST: ${SMTP_HOST:-}
      SMTP_PORT: ${SMTP_PORT:-}
      SMTP_USER: ${SMTP_USER:-}
      SMTP_PASS: ${SMTP_PASS:-}
      SMTP_FROM: ${SMTP_FROM:-}
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      MOBILE_APP_URL: ${MOBILE_APP_URL:-http://localhost:19000}
      # Optional: Redis für Rate-Limiting-Store
      REDIS_URL: ${REDIS_URL:-redis://redis:6379/0}
      # Auth-Rate-Limits (IP-basiert)
      RATE_LIMIT_MAX: ${RATE_LIMIT_MAX:-10}
      RATE_LIMIT_WINDOW_MS: ${RATE_LIMIT_WINDOW_MS:-60000}
      LOG_LEVEL: ${LOG_LEVEL:-info}
      LOG_FORMAT: ${LOG_FORMAT:-}
      DOCUMENT_STORAGE_ROOT: ${DOCUMENT_STORAGE_ROOT:-/srv/documents}
      # CORS
      CORS_ORIGIN: ${CORS_ORIGIN:-http://localhost:5173}
      # Trusted Proxies für X-Forwarded-For (kommaseparierte IP/CIDR)
      TRUSTED_PROXIES: ${TRUSTED_PROXIES:-}
    # ports:
    ports:
      - '3001:3001' # Direktzugriff (z. B. Frontend .env zeigt auf :3001)
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.api.rule=Host(`${DOMAIN:-localhost}`)"
      - "traefik.http.routers.api.entrypoints=websecure"
      - "traefik.http.routers.api.tls.certresolver=myresolver"
      - "traefik.http.routers.api.service=api"
      - "traefik.http.services.api.loadbalancer.server.port=3001"
      # HTTP -> HTTPS Redirect
      - "traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https"
      - "traefik.http.routers.api-http.rule=Host(`${DOMAIN:-localhost}`)"
      - "traefik.http.routers.api-http.entrypoints=web"
      - "traefik.http.routers.api-http.middlewares=redirect-to-https"
      - "traefik.http.routers.api-http.service=api"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    networks:
      - sicherheitsdienst-network
    healthcheck:
      # Liveness-Check via /health (alias für /healthz, ohne DB-Abhängigkeit)
      test: ['CMD-SHELL', 'wget -qO- http://localhost:3001/health || exit 1']
      interval: 15s
      timeout: 5s
      retries: 10
    # Start API without migrations; run deploy separately to avoid restart loops on DB outages
    command: >-
      sh -lc "node dist/server.js"
    volumes:
      - /srv/documents:/srv/documents:rw

  # Traefik Reverse Proxy
  traefik:
    image: traefik:v3.0
    container_name: sicherheitsdienst-traefik
    restart: always
    command:
      # - "--log.level=DEBUG"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      # Let's Encrypt / ACME
      - "--certificatesresolvers.myresolver.acme.httpchallenge=true"
      - "--certificatesresolvers.myresolver.acme.httpchallenge.entrypoint=web"
      - "--certificatesresolvers.myresolver.acme.email=${ACME_EMAIL:?ACME_EMAIL required}"
      - "--certificatesresolvers.myresolver.acme.storage=/letsencrypt/acme.json"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - "./letsencrypt:/letsencrypt"
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
    networks:
      - sicherheitsdienst-network

  # Redis (optional, Rate-Limit Store)
  redis:
    image: redis:7-alpine
    container_name: sicherheitsdienst-redis
    restart: unless-stopped
    # SECURITY: Port nicht öffentlich exponieren - nur intern im Docker-Netzwerk
    # ports:
    #   - '6379:6379'
    networks:
      - sicherheitsdienst-network

  # pgAdmin (Datenbank-Verwaltung)
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: sicherheitsdienst-pgadmin
    restart: always
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL:-admin@admin.com}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD:?PGADMIN_DEFAULT_PASSWORD required}
    # SECURITY: Port nicht öffentlich exponieren - nur intern im Docker-Netzwerk
    # Zugriff via: docker exec -it sicherheitsdienst-db psql -U admin -d sicherheitsdienst_db
    # ports:
    #   - '8080:80'
    depends_on:
      db:
        condition: service_healthy
    networks:
      - sicherheitsdienst-network
    healthcheck:
      test: ['CMD-SHELL', 'wget --spider -q http://localhost:80 || exit 1']
      interval: 15s
      timeout: 5s
      retries: 10

volumes:
  db-data:

networks:
  sicherheitsdienst-network:
    driver: bridge
