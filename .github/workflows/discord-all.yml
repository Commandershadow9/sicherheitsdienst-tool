name: Notify Discord

on:
  workflow_dispatch: {}              # manueller Test-Trigger (Run workflow)
  push:
    branches:
      - main                         # passe bei Bedarf an (oder nutze '**' f√ºr alle)
    tags:
      - 'v*'                         # Releases per Tag
  pull_request:
    types: [opened, synchronize, reopened, closed, ready_for_review, converted_to_draft]
  workflow_run:                      # CI/Smoke-Ergebnisse melden
    workflows: [ "ci", "CI", "build", "test", "health-smoke", "metrics-smoke", "docker-release" ]   # muss den Workflow-Namen(en) entsprechen
    types: [completed]
  release:
    types: [published]

permissions:
  contents: read
  actions: read

jobs:
  notify:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      # Checkout nur wenn wir Dateien brauchen (push/release/dispatch)
      - name: Checkout
        if: ${{ github.event_name == 'push' || github.event_name == 'release' || github.event_name == 'workflow_dispatch' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure jq, curl, python3 present
        run: sudo apt-get update && sudo apt-get install -y jq curl python3

      - name: Build Discord payload
        id: build
        shell: bash
        env:
          GH_EVENT_JSON: ${{ toJson(github.event) }}
        run: |
          set -euo pipefail

          esc_json () { python3 -c 'import sys, json; print(json.dumps(sys.stdin.read())[1:-1])'; }

          actor="${{ github.actor }}"
          repo="${{ github.repository }}"
          repo_url="https://github.com/${repo}"
          run_url="https://github.com/${repo}/actions/runs/${{ github.run_id }}"
          avatar="https://github.com/${actor}.png"
          ts="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          event="${{ github.event_name }}"

          workflow_run_id="$(echo "$GH_EVENT_JSON" | jq -r '.workflow_run.id // empty')"
          if [ "$event" = "workflow_run" ] && [ -n "$workflow_run_id" ]; then
            run_url="https://github.com/${repo}/actions/runs/${workflow_run_id}"
          fi

          TITLE=""
          DESC=""
          COLOR=5793266
          ICON="https://raw.githubusercontent.com/primer/octicons/main/icons/info-24.svg"
          FIELDS="[]"

          embed_url="$run_url"

          if [ "$event" = "workflow_dispatch" ]; then
            TITLE="üîî Testbenachrichtigung"
            DESC="Manuell ausgel√∂st von **${actor}**\n${run_url}"
            COLOR=4437377
            ICON="https://raw.githubusercontent.com/primer/octicons/main/icons/bell-24.svg"
            FIELDS=$(jq -n --arg repo_url "$repo_url" '[{"name":"Repository","value":$repo_url}]')
          elif [ "$event" = "push" ]; then
            ref="${GITHUB_REF_NAME:-unknown}"
            sha="${GITHUB_SHA:-}"
            short_sha="${sha:0:7}"
            before="$(echo "$GH_EVENT_JSON" | jq -r '.before // ""')"
            compare_url="${repo_url}/compare/${before}...${sha}"

            TOTAL_COMMITS="$(echo "$GH_EVENT_JSON" | jq -r '(.commits // []) | length')"
            COMMITS_RAW="$(echo "$GH_EVENT_JSON" | jq -r '
              (.commits // [])[0:5][]?
              | "- **" + (.id[0:7]) + "**: " + (((.message // "") | gsub("\n"; " "))[0:80]) + (if ((.message // "") | length) > 80 then "..." else "" end) + "  ‚Äî _" + ((.author.username // .author.name) // "unknown") + "_"
            ')"
            [ -z "$COMMITS_RAW" ] && COMMITS_RAW="- (keine Commits √ºbermittelt)"

            # Hinweis wenn mehr als 5 Commits
            if [ "$TOTAL_COMMITS" -gt 5 ]; then
              COMMITS_RAW="${COMMITS_RAW}\n\n*...und $((TOTAL_COMMITS - 5)) weitere Commits. [Alle anzeigen](${compare_url})*"
            fi

            # Discord Field-Limit: 1024 Zeichen pro Field (sicher bei 600 splitten)
            # Wenn Commit-Liste zu lang (>600 Zeichen), aufteilen
            if [ "${#COMMITS_RAW}" -gt 600 ]; then
              # Erste 600 Zeichen nehmen und bei letztem Zeilenumbruch abschneiden
              COMMITS_PART1="$(echo "$COMMITS_RAW" | head -c 600 | sed 's/\(.*\)-.*/\1/')"
              COMMITS_PART2="$(echo "$COMMITS_RAW" | tail -c +601)"

              # Falls Teil 2 auch zu lang, nochmal k√ºrzen
              if [ "${#COMMITS_PART2}" -gt 600 ]; then
                COMMITS_PART2="${COMMITS_PART2:0:600}...\n\n*Weitere Details: ${compare_url}*"
              fi

              # Zwei separate Embeds erstellen
              MULTI_EMBED=true
            else
              COMMITS_PART1="$COMMITS_RAW"
              COMMITS_PART2=""
              MULTI_EMBED=false
            fi

            TITLE="üì¶ Push auf ${repo} ‚Äî ${ref}"
            DESC="**Akteur:** ${actor} | **Branch:** ${ref} | **SHA:** \`${short_sha}\`"
            COLOR=5814783
            ICON="https://raw.githubusercontent.com/primer/octicons/main/icons/upload-24.svg"
            embed_url="$compare_url"

            # Compare-Link prominenter bei Multi-Embed
            if [ "$MULTI_EMBED" = "true" ]; then
              # Erster Embed (Teil 1) mit Compare-Link
              FIELDS=$(jq -n \
                --arg commits "$COMMITS_PART1" \
                --arg compare_url "$compare_url" \
                '[{"name":"Commit Details (Teil 1 - gek√ºrzt)","value":$commits},{"name":"üìã Alle Details","value":("[Vollst√§ndige Commit-Historie](" + $compare_url + ")")}]')
            else
              # Single Embed
              FIELDS=$(jq -n \
                --arg commits "$COMMITS_PART1" \
                '[{"name":"Commit Details","value":$commits}]')
            fi
          elif [ "$event" = "pull_request" ]; then
            pr_title='${{ github.event.pull_request.title }}'
            pr_num='${{ github.event.pull_request.number }}'
            pr_state='${{ github.event.pull_request.state }}'
            pr_merged='${{ github.event.pull_request.merged }}'
            pr_url='${{ github.event.pull_request.html_url }}'
            base='${{ github.event.pull_request.base.ref }}'
            head='${{ github.event.pull_request.head.ref }}'
            draft='${{ github.event.pull_request.draft }}'
            labels="$(echo "$GH_EVENT_JSON" | jq -r '[.pull_request.labels[]?.name] | select(length>0) | join(", ") // ""')"
            assignees="$(echo "$GH_EVENT_JSON" | jq -r '[.pull_request.assignees[]?.login] | select(length>0) | join(", ") // ""')"

            TITLE="üîÄ PR #${pr_num}: ${pr_title}"
            status_emoji="üü¢"
            [ "$pr_state" != "open" ] && status_emoji="üü°"
            [ "${pr_merged}" = "true" ] && status_emoji="üü£"
            [ "${draft}" = "true" ] && status_emoji="‚ö™"
            DESC="${status_emoji} **Status:** ${pr_state}  |  **Merged:** ${pr_merged}\n**Akteur:** ${actor}\n${pr_url}"
            COLOR=9055202
            ICON="https://raw.githubusercontent.com/primer/octicons/main/icons/git-pull-request-24.svg"
            embed_url="${pr_url}"
            FIELDS=$(jq -n \
              --arg base "$base" --arg head "$head" --arg repo_url "$repo_url" \
              --arg labels "$labels" --arg assignees "$assignees" \
              '[{"name":"Basis ‚Üí Head","value":("`"+$base+"` ‚Üí `"+$head+"`")},{"name":"Repository","value":$repo_url}] \
               + (if $labels != "" then [{"name":"Labels","value":$labels}] else [] end) \
               + (if $assignees != "" then [{"name":"Assignees","value":$assignees}] else [] end)')
          elif [ "$event" = "workflow_run" ]; then
            name='${{ github.event.workflow_run.name }}'
            conc='${{ github.event.workflow_run.conclusion }}'
            TITLE="üß™ CI: ${name}"
            case "$conc" in
              success) COLOR=4437377; status="‚úÖ Erfolg";;
              failure) COLOR=13631488; status="‚ùå Fehlgeschlagen";;
              cancelled) COLOR=14540253; status="‚èπÔ∏è Abgebrochen";;
              skipped) COLOR=15132390; status="‚è≠Ô∏è √úbersprungen";;
              *) COLOR=8421504; status="‚ÑπÔ∏è ${conc}";;
            esac
            DESC="**Akteur:** ${actor}\n**Ergebnis:** ${status}\n${run_url}"
            ICON="https://raw.githubusercontent.com/primer/octicons/main/icons/checklist-24.svg"
            embed_url="$run_url"
            docker_note="Image Scan (SARIF) & SBOM als Artefakte im Run verf√ºgbar."
            health_note="‚Ä¢ [Artefakte](${run_url}#artifacts) ‚Äì server.log, healthz.json, readyz.json"
            metrics_note="‚Ä¢ [Artefakte](${run_url}#artifacts) ‚Äì server.log, metrics.txt\\n‚Ä¢ Dashboards: https://github.com/${repo}/blob/main/monitoring/grafana/dashboards/latency-and-errors.json"
            FIELDS=$(jq -n --arg name "$name" --arg repo_url "$repo_url" --arg run "$run_url" \
              '[{"name":"Workflow","value":$name},{"name":"Repository","value":$repo_url}]' \
              | jq --arg name "$name" --arg note "$docker_note" \
                   --arg note2 "$health_note" \
                   --arg note3 "$metrics_note" \
                'if $name == "docker-release" then . + [{"name":"Artefakte","value":$note}] elif $name == "health-smoke" then . + [{"name":"Artefakte","value":$note2}] elif $name == "metrics-smoke" then . + [{"name":"Artefakte","value":$note3}] else . end')
          elif [ "$event" = "release" ]; then
            tag='${{ github.event.release.tag_name }}'
            rname='${{ github.event.release.name }}'
            rurl='${{ github.event.release.html_url }}'
            [ -z "$rurl" ] && rurl="${repo_url}/releases/tag/${tag}"

            TITLE="üè∑Ô∏è Release ${tag}"
            [ -n "$rname" ] && TITLE="üè∑Ô∏è ${rname} (${tag})"
            DESC="**Repository:** ${repo}\n**Akteur:** ${actor}\n**Release:** ${rurl}"
            COLOR=5793266
            ICON="https://raw.githubusercontent.com/primer/octicons/main/icons/tag-24.svg"
            embed_url="$rurl"

            version="${tag#v}"
            CHANGELOG_SECTION=""
            if [ -f CHANGELOG.md ]; then
              CHANGELOG_SECTION="$(awk -v ver="$version" '
                BEGIN{found=0}
                tolower($0) ~ "^##[[:space:]]*\\[?v?" tolower(ver) "\\]?" { if(!found){found=1; next} }
                found && /^##[[:space:]]*\[?v?[0-9]/ {exit}
                found {print}
              ' CHANGELOG.md)"
            fi
            release_body="$(echo "$GH_EVENT_JSON" | jq -r '.release.body // ""')"
            TEXT="$release_body"
            [ -z "$TEXT" ] && TEXT="$CHANGELOG_SECTION"
            [ -z "$TEXT" ] && TEXT="(Keine Release-Notes/Changelog gefunden.)"
            CLEAN_SECTION="$(printf '%s' "$TEXT")"

            # Discord Field-Limit: 1024 Zeichen pro Field (sicher bei 600 splitten)
            # Wenn Release-Notes zu lang (>600 Zeichen), aufteilen
            if [ "${#CLEAN_SECTION}" -gt 600 ]; then
              # Erste 600 Zeichen nehmen und bei letztem Zeilenumbruch abschneiden
              NOTES_PART1="$(echo "$CLEAN_SECTION" | head -c 600 | sed 's/\(.*\)\n.*/\1/')"
              NOTES_PART2="$(echo "$CLEAN_SECTION" | tail -c +601)"

              # Falls Teil 2 auch zu lang, nochmal k√ºrzen
              if [ "${#NOTES_PART2}" -gt 600 ]; then
                NOTES_PART2="${NOTES_PART2:0:600}...\n\n*Vollst√§ndige Release Notes: ${rurl}*"
              fi

              # Zwei separate Embeds erstellen
              MULTI_EMBED=true
            else
              NOTES_PART1="$CLEAN_SECTION"
              NOTES_PART2=""
              MULTI_EMBED=false
            fi

            if [ "$MULTI_EMBED" = "true" ]; then
              # Erster Embed (Teil 1)
              FIELDS=$(jq -n \
                --arg changes "$NOTES_PART1" \
                --arg links "$(printf "‚Ä¢ Vollst√§ndige Notes: %s\n‚Ä¢ Repository: %s\n‚Ä¢ Actions: %s" "$rurl" "$repo_url" "$run_url")" \
                '[{"name":"Release Notes (Teil 1)","value":$changes},{"name":"Links","value":$links}]')
            else
              # Single Embed
              FIELDS=$(jq -n \
                --arg changes "$NOTES_PART1" \
                --arg links "$(printf "‚Ä¢ Repo: %s\n‚Ä¢ Actions: %s\n‚Ä¢ Tag: %s" "$repo_url" "$run_url" "$rurl")" \
                '[{"name":"Release Notes / Changelog","value":$changes},{"name":"Links","value":$links}]')
            fi
          fi

          # Erstes Payload erstellen
          jq -n \
            --arg username "GitHub ¬∑ ${repo}" \
            --arg avatar_url "${avatar}" \
            --arg title "$TITLE" \
            --arg description "$DESC" \
            --arg ts "${ts}" \
            --arg icon "${ICON}" \
            --arg date "$(date -u +%Y-%m-%d)" \
            --argjson fields "$FIELDS" \
            --arg color "${COLOR}" \
            --arg url "$embed_url" \
            --arg author_name "$actor" \
            --arg author_url "https://github.com/${actor}" \
            --arg author_icon "$avatar" \
            '{username:$username, avatar_url:$avatar_url, embeds:[{title:$title, url:$url, description:$description, color:($color|tonumber), timestamp:$ts, thumbnail:{url:$icon}, author:{name:$author_name, url:$author_url, icon_url:$author_icon}, fields:$fields, footer:{text:("Automatische Benachrichtigung ‚Ä¢ " + $date)}}]}' \
            > payload.json

          # Zweites Payload wenn MULTI_EMBED
          if [ "$event" = "push" ] && [ "${MULTI_EMBED:-false}" = "true" ] && [ -n "${COMMITS_PART2:-}" ]; then
            FIELDS2=$(jq -n --arg commits "$COMMITS_PART2" '[{"name":"Commit Details (Teil 2)","value":$commits}]')
            jq -n \
              --arg username "GitHub ¬∑ ${repo}" \
              --arg avatar_url "${avatar}" \
              --arg title "üì¶ Push auf ${repo} ‚Äî ${ref} (Fortsetzung)" \
              --arg description "**Weitere Commit-Details**" \
              --arg ts "${ts}" \
              --arg icon "${ICON}" \
              --arg date "$(date -u +%Y-%m-%d)" \
              --argjson fields "$FIELDS2" \
              --arg color "${COLOR}" \
              --arg url "$embed_url" \
              --arg author_name "$actor" \
              --arg author_url "https://github.com/${actor}" \
              --arg author_icon "$avatar" \
              '{username:$username, avatar_url:$avatar_url, embeds:[{title:$title, url:$url, description:$description, color:($color|tonumber), timestamp:$ts, thumbnail:{url:$icon}, author:{name:$author_name, url:$author_url, icon_url:$author_icon}, fields:$fields, footer:{text:("Automatische Benachrichtigung ‚Ä¢ " + $date)}}]}' \
              > payload2.json
            echo "has_payload2=true" >> "$GITHUB_OUTPUT"
          elif [ "$event" = "release" ] && [ "${MULTI_EMBED:-false}" = "true" ] && [ -n "${NOTES_PART2:-}" ]; then
            FIELDS2=$(jq -n \
              --arg notes "$NOTES_PART2" \
              --arg rurl "${rurl}" \
              '[{"name":"Release Notes (Teil 2)","value":$notes},{"name":"Vollst√§ndige Notes","value":$rurl}]')
            jq -n \
              --arg username "GitHub ¬∑ ${repo}" \
              --arg avatar_url "${avatar}" \
              --arg title "üè∑Ô∏è Release ${tag} (Fortsetzung)" \
              --arg description "**Weitere Release-Details**" \
              --arg ts "${ts}" \
              --arg icon "${ICON}" \
              --arg date "$(date -u +%Y-%m-%d)" \
              --argjson fields "$FIELDS2" \
              --arg color "${COLOR}" \
              --arg url "$embed_url" \
              --arg author_name "$actor" \
              --arg author_url "https://github.com/${actor}" \
              --arg author_icon "$avatar" \
              '{username:$username, avatar_url:$avatar_url, embeds:[{title:$title, url:$url, description:$description, color:($color|tonumber), timestamp:$ts, thumbnail:{url:$icon}, author:{name:$author_name, url:$author_url, icon_url:$author_icon}, fields:$fields, footer:{text:("Automatische Benachrichtigung ‚Ä¢ " + $date)}}]}' \
              > payload2.json
            echo "has_payload2=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_payload2=false" >> "$GITHUB_OUTPUT"
          fi

          # als Ausgabe (base64) f√ºr den n√§chsten Step
          base64 -w0 < payload.json > payload.b64 || base64 < payload.json > payload.b64
          echo "payload=$(cat payload.b64)" >> "$GITHUB_OUTPUT"

          if [ -f payload2.json ]; then
            base64 -w0 < payload2.json > payload2.b64 || base64 < payload2.json > payload2.b64
            echo "payload2=$(cat payload2.b64)" >> "$GITHUB_OUTPUT"
          fi

      - name: Send to Discord (with retry)
        continue-on-error: true
        env:
          WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          WEBHOOK_CI: ${{ secrets.DISCORD_WEBHOOK_CI }}
        shell: bash
        run: |
          set -euo pipefail
          # W√§hle Kanal: f√ºr workflow_run (CI-Status) bevorzugt CI-Hook, andernfalls Default
          URL="$WEBHOOK"
          if [ "${{ github.event_name }}" = "workflow_run" ] && [ -n "${WEBHOOK_CI:-}" ]; then
            URL="$WEBHOOK_CI"
          fi
          test -n "${URL:-}" || { echo "::error::Secret DISCORD_WEBHOOK (oder _CI) fehlt"; exit 1; }
          # base64 decode (Linux/macOS compatible)
          echo "${{ steps.build.outputs.payload }}" | base64 -d > payload.json || echo "${{ steps.build.outputs.payload }}" | base64 -D > payload.json

          # bis zu 5 Versuche (z.B. bei 429 Rate Limit)
          for i in 1 2 3 4 5; do
            http_code=$(curl -sS -H "Content-Type: application/json" -d @payload.json "$URL" -o resp.txt -w "%{http_code}" || echo "000")
            echo "Discord HTTP: $http_code (try $i)"
            if [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
              echo "OK"; break
            fi
            echo "Antwort:"
            cat resp.txt || true
            sleep $((i*2))
          done

          # finaler Check
          if [ "$http_code" -lt 200 ] || [ "$http_code" -ge 300 ]; then
            echo "::warning::Discord-Request fehlgeschlagen (HTTP $http_code); Workflow wird nicht blockiert."
          fi

          # Zweiter Post wenn vorhanden
          if [ "${{ steps.build.outputs.has_payload2 }}" = "true" ]; then
            echo ""
            echo "Sende zweiten Post (Fortsetzung)..."
            sleep 2  # Kurze Pause zwischen Posts

            echo "${{ steps.build.outputs.payload2 }}" | base64 -d > payload2.json || echo "${{ steps.build.outputs.payload2 }}" | base64 -D > payload2.json

            for i in 1 2 3 4 5; do
              http_code2=$(curl -sS -H "Content-Type: application/json" -d @payload2.json "$URL" -o resp2.txt -w "%{http_code}" || echo "000")
              echo "Discord HTTP (Teil 2): $http_code2 (try $i)"
              if [ "$http_code2" -ge 200 ] && [ "$http_code2" -lt 300 ]; then
                echo "OK"; break
              fi
              echo "Antwort:"
              cat resp2.txt || true
              sleep $((i*2))
            done

            if [ "$http_code2" -lt 200 ] || [ "$http_code2" -ge 300 ]; then
              echo "::warning::Discord-Request Teil 2 fehlgeschlagen (HTTP $http_code2); Workflow wird nicht blockiert."
            fi
          fi
